<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Tarefa1_2022li1g079</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Leonor Cunha &lt;a103997@alunos.uminho.pt&gt;<br />Tiago Barros &lt;a104530@alunos.uminho.pt&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Tarefa1_2022li1g079</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>M&#243;dulo para a realiza&#231;&#227;o da Tarefa 1 do projeto de LI1 em 2022/23.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:mapaValido">mapaValido</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:mapaValido1">mapaValido1</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:mapaValido2">mapaValido2</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:mapaValido3">mapaValido3</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:conta">conta</a> :: [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>] -&gt; [[<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]]</li><li class="src short"><a href="#v:contaAux">contaAux</a> :: [[<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]] -&gt; Int</li><li class="src short"><a href="#v:mapaValido4">mapaValido4</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:contaAux1">contaAux1</a> :: [[<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]] -&gt; Int</li><li class="src short"><a href="#v:mapaValido5">mapaValido5</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:mapaValido6">mapaValido6</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:mapaValido7">mapaValido7</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool</li><li class="src short"><a href="#v:conta7">conta7</a> :: [(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])] -&gt; [[(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])]]</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:mapaValido" class="def">mapaValido</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:mapaValido" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o mapaValido &#233; a fun&#231;&#227;o principal e funciona a partir da jun&#231;&#227;o das v&#225;rias fun&#231;&#245;es auxiliares. (Se o resultado de todas as fun&#231;&#245;es auxiliares for Verdadeiro, ent&#227;o a fun&#231;&#227;o mapaValido tamb&#233;m o ser&#225;.)
<code>mapaValido :: Mapa -&gt; Bool
mapaValido (Mapa c ((tr, (x:y)):t)) = mapaValido1 (Mapa c ((tr, (x:y)):t)) &amp;&amp; mapaValido2 (Mapa c ((tr, (x:y)):t)) &amp;&amp; mapaValido3 (Mapa c ((tr, (x:y)):t)) &amp;&amp; mapaValido4 (Mapa c ((tr, (x:y)):t)) &amp;&amp; mapaValido5 (Mapa c ((tr, (x:y)):t)) &amp;&amp; mapaValido6 (Mapa c ((tr, (x:y)):t)) &amp;&amp; mapaValido7 (Mapa c ((tr, (x:y)):t))</code></p></div></div><div class="top"><p class="src"><a id="v:mapaValido1" class="def">mapaValido1</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:mapaValido1" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o mapaValido1 certifica que n&#227;o existem obst&#225;culos em terrenos impr&#243;prios. 
Na primeira linha tem o caso de paragem, onde se a lista de [Terreno, (Obst&#225;culos)] est&#225; vazia e por isso n&#227;o h&#225; erros.
Nas linhas seguintes &#233; determinado o que fazer no caso dos tr&#234;s terrenos poss&#237;veis. Na estrada, os obst&#225;culos poss&#237;veis s&#227;o carros, na relva, as &#225;rvores e nos rios, troncos.
Caso algum dos elementos que n&#227;o pertence ao respetivo terreno se encontrar na lista de obst&#225;culos (utilizando a fun&#231;&#227;o elem), o mapa deixa de ser v&#225;lido. Por exemplo, n&#227;o podem existir nem &#225;rvores, nem carros no rio.
Em todos os casos de verifica&#231;&#227;o dos terrenos com os obst&#225;culos existe um otherwise no caso de n&#227;o serem encotrados obst&#225;culos impr&#243;prios, permitindo verificar a totalidade do mapa e aferir a sua veracidade ou n&#227;o.
A fun&#231;&#227;o retornara um Bool para depois ser analisado na fun&#231;&#227;o principal.
<code>mapaValido1 :: Mapa -&gt; Bool
mapaValido1 (Mapa c []) = True
mapaValido1 (Mapa c (((Estrada n),(x:y)):t)) 
    |(elem Arvore (x:y) || elem Tronco (x:y)) = False
    |otherwise = mapaValido1 (Mapa c t)
mapaValido1 (Mapa c (((Rio n),(x:y)):t)) 
    |(elem Carro (x:y) || elem Arvore (x:y)) = False
    |otherwise = mapaValido1 (Mapa c t)     
mapaValido1 (Mapa c (( Relva, (x:y)):t)) 
    |(elem Tronco (x:y) || elem Carro (x:y)) = False
    | otherwise = mapaValido1 (Mapa c t)</code></p></div></div><div class="top"><p class="src"><a id="v:mapaValido2" class="def">mapaValido2</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:mapaValido2" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o mapaValido2 verifica se existem rios cont&#237;guos com a mesma dire&#231;&#227;o (o que n&#227;o pode acontecer).
Os rios, assim como a estrada, tem velocidade associada ao terreno pois estes tem movimento. Se a velocidade for um valor positivo ent&#227;o os obst&#225;culos movem-se da esquerda para a direita, se for negativo &#233; o contr&#225;rio.
Para verificar se os rios cont&#237;guos tem a mesma dire&#231;&#227;o, avaliamos a velocidade (se s&#227;o valores ambos positivos, ambos negativos ou os dois diferentes).
Na primeira linha, assim como na fun&#231;&#227;o mapaValido1, temos o caso de paragem onde a lista [Terreno, (Obst&#225;culos)] est&#225; vazia e por isso n&#227;o h&#225; erros.
Na segunda linha, caso a fun&#231;&#227;o receba um mapa que s&#243; tenha um rio, ou seja, sem mais nenhum rio a seguir, o mapa estar&#225; v&#225;lido pois n&#227;o tem nenhum rio cont&#237;gui, podendo ter qualquer velocidade.
De seguida, nas linhas 3 e 4, caso receba como primeiro terreno estrada ou relva, ir&#225; avaliar o resto da lista pois n&#227;o existe nenhuma restri&#231;&#227;o para esses terrenos nesta fun&#231;&#227;o.
Caso a fun&#231;&#227;o receba primeiramente o terreno rio mas o segundo terreno &#233; relva ou estrada, a fun&#231;&#227;o ir&#225; verificar o resto da lista, n&#227;o havendo nenhum problema nestas combina&#231;&#245;es.
Por fim, no caso da fun&#231;&#227;o receber dois rios seguidos, esta vai verificar se as velocidades tem valores iguais, ou seja, no caso do mapa nao ser v&#225;lido.
Se os valores forem contr&#225;rios (positivo, negativo ou o contr&#225;rio) o mapa ser&#225; v&#225;lido (at&#233; aquele caso) e a fun&#231;&#227;o verifica o resto da lista. 
<code>mapaValido2 :: Mapa -&gt; Bool
mapaValido2 (Mapa c []) = True
mapaValido2 (Mapa c ((Rio n, (x:y)):[])) = True
mapaValido2 (Mapa c ((Relva, (x:y)):t)) = mapaValido2 (Mapa c t)
mapaValido2 (Mapa c ((Estrada n, (x:y)):t)) = mapaValido2 (Mapa c t)
mapaValido2 (Mapa c ((Rio n, (x:y)): (Relva,  (x':y')):t)) = mapaValido2 (Mapa c t)
mapaValido2 (Mapa c ((Rio n, (x:y)): (Estrada n', (x':y')):t)) = mapaValido2 (Mapa c t) 
mapaValido2 (Mapa c ((Rio n, (x:y)): (Rio n', (x':y')): t))
    | n &gt; 0  &amp;&amp; n' &gt;0 = False
    | n &lt; 0 &amp;&amp; n' &lt; 0 = False
    |otherwise = mapaValido2 (Mapa c ((Rio n', (x':y')):t))
</code></p></div></div><div class="top"><p class="src"><a id="v:mapaValido3" class="def">mapaValido3</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:mapaValido3" class="selflink">#</a></p><div class="doc"><p>Na fun&#231;&#227;o mapaValido3 verifamos que os troncos n&#227;o tem mais de 5 unidades.
Como nas fun&#231;&#245;es vistas at&#233; agora, o caso de paragem na primeira linha acontece por n&#227;o ter erro nenhum, a lista de obst&#225;culos est&#225; vazia.
No caso de o primeiro terreno ser relva ou estrada, que n&#227;o estamos a avaliar nesta fun&#231;&#227;o, a fun&#231;&#227;o ir&#225; avaliar o resto da lista (Terreno,[Obst&#225;culo]) (recursividade).
Considerando que em rio  a linha tem movimento, os obstaculo movem-se do final para o inicio. Se tiverem cinco troncos no inicio da linha e outro no final, com o movimento, ficariam seis troncos seguido, o que nao &#233; v&#225;lido.
Por isso, na quarta linha verificamos que os casos em que na movimenta&#231;ao da linha ficariam troncos a mais seguidos, o resultado &#233; falso. Comparamos o comprimento da primeira e &#250;ltima linha de obst&#225;culos iguais.
Quando o primeiro terreno coincide com Rio, a partir de duas fun&#231;&#245;es auxiliares que criamos (conta e contaAux - agrupa elementos iguais e consecutivos numa lista; 
procura e devolve o numero de elementos com maior numero de Troncos das listas resultantes da primeira fun&#231;&#227;o (respetivamente)), se existirem troncos com mais de 5 unidades, o mapa n&#227;o 
ser&#225; v&#225;lido pois n&#227;o cumpre os requisitos. Se n&#227;o existir nenhum caso onde existem troncos com mais de cinco unidades ent&#227;o, verificamos o resto da lista e se nada ocorrer em contr&#225;rio,
o mapa &#233; v&#225;lido.
@mapaValido3 :: Mapa -&gt; Bool
mapaValido3 (Mapa c []) = True
mapaValido3 (Mapa c ((Relva, (x:y)):t)) = mapaValido3 (Mapa c t)
mapaValido3 (Mapa c ((Estrada n, (x:y)):t)) = mapaValido3 (Mapa c t) 
mapaValido3 (Mapa c ((Rio n, (x:y)):t)) | length (conta (x:y)) &gt; 1 &amp;&amp; elem Tronco (head (conta (x:y))) &amp;&amp; elem Tronco (last (conta (x:y))) &amp;&amp; length (head (conta (x:y))) + length (last (conta (x:y))) &gt; 5 = False 
                                        | contaAux (conta (x:y)) &gt; 5 = False
                                        | otherwise = mapaValido3 (Mapa c t)</p><p>conta :: [Obstaculo] -&gt; [[Obstaculo]] 
conta [] = [] 
conta [x] = [[x]]
conta (x:y:t) | elem x (head r ) = (x:(head r)) : tail r
              | otherwise = [x] :r
                where r = conta (y:t)</p><p>contaAux :: [[Obstaculo]] -&gt; Int
contaAux [x] = length x
contaAux [] = 0
contaAux ((x:y):t) | (elem Tronco (x:y)) &amp;&amp; (length (x:y) &gt;= (contaAux t)) = length (x:y)
                   | otherwise = contaAux t
@</p></div></div><div class="top"><p class="src"><a id="v:conta" class="def">conta</a> :: [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>] -&gt; [[<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]] <a href="#v:conta" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:contaAux" class="def">contaAux</a> :: [[<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]] -&gt; Int <a href="#v:contaAux" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:mapaValido4" class="def">mapaValido4</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:mapaValido4" class="selflink">#</a></p><div class="doc"><p>Pela mesma l&#243;gica que a fun&#231;&#227;o mapaValido3, para fun&#231;&#227;o mapaValido4, que pretende verificar se n&#227;o existem carros com mais de tr&#234;s unidades, utilizamos a fun&#231;&#227;o auxilar conta (criada em cima) e
a fun&#231;&#227;o contaAux1 que &#233; uma varia&#231;&#227;o da fun&#231;&#227;o contaAux mas procura e devolve o numero de elementos com maior numero de Carros, e n&#227;o Troncos, das listas resultantes da primeira fun&#231;&#227;o.
Na primeira linha est&#225; o caso de paragem semelhante &#225;s fun&#231;&#245;es vistas at&#233; ao momento (se a lista n&#227;o cont&#233;m nada, n&#227;o pode dar erro).
Considerando que em estrada a linha tem movimento, os obstaculo movem-se do final para o inicio. Se tiverem tres carros no inicio da linha e outro no final, com o movimento, ficariam quatro carros seguido, o que nao &#233; v&#225;lido.
Por isso, na quarta linha verificamos que os casos em que na movimenta&#231;ao da linha ficariam carros a mais seguidos, o resultado &#233; falso. Comparamos o comprimento da primeira e &#250;ltima linha de obst&#225;culos iguais.
De seguida definimos os casos em que o primeiro terreno n&#227;o &#233; estrada, ou seja, relva ou rio, em que a fun&#231;&#227;o ir&#225; apenas verificar o resto da lista.
Quando a fun&#231;&#227;o encontra um terreno estrada (utiliza as fun&#231;&#245;es auxiliares) verifica se o n&#250;mero de carros seguidos nessa lista &#233; superior a tr&#234;s. Se sim, o mapa n&#227;o &#233; v&#225;lido, se n&#227;o ent&#227;o verificamos 
a validade do resto da lista.
@mapaValido4 :: Mapa -&gt; Bool
mapaValido4 (Mapa c []) = True
mapaValido4 (Mapa c ((Relva, (x:y)):t)) = mapaValido4 (Mapa c t)
mapaValido4 (Mapa c ((Rio n, (x:y)):t)) = mapaValido4 (Mapa c t) 
mapaValido4 (Mapa c ((Estrada n, (x:y)):t)) |length (conta (x:y)) &gt; 1 &amp;&amp; elem Carro (head (conta (x:y))) &amp;&amp; elem Carro (last (conta (x:y))) &amp;&amp; length (head (conta (x:y))) + length (last (conta (x:y))) &gt; 3 = False 
                                            | contaAux1 (conta (x:y)) &gt; 3 = False
                                            | otherwise = mapaValido4 (Mapa c t)</p><p>conta :: [Obstaculo] -&gt; [[Obstaculo]] 
conta [] = [] 
conta [x] = [[x]]
conta (x:y:t) | elem x (head r ) = (x:(head r)) : tail r
              | otherwise = [x] :r
                where r = conta (y:t)</p><p>contaAux1 :: [[Obstaculo]] -&gt; Int
contaAux1 [x] = length x
contaAux1 [] = 0
contaAux1 ((x:y):t) | (elem Carro (x:y)) &amp;&amp; (length (x:y) &gt;= (contaAux1 t)) = length (x:y)
                    | otherwise = contaAux1 t                                        @</p></div></div><div class="top"><p class="src"><a id="v:contaAux1" class="def">contaAux1</a> :: [[<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>]] -&gt; Int <a href="#v:contaAux1" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:mapaValido5" class="def">mapaValido5</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:mapaValido5" class="selflink">#</a></p><div class="doc"><p>mapaValido5 verifica se existe alguma linha do mapa constitu&#237;da exclusivamente por obst&#225;culos sem espa&#231;os vazios (Nenhum).
Caso de paragem na primeira linha, caso a lista se vazia o mapa &#233; v&#225;lido.
Quando recebe um mapa, procura se existe algum elemento na lista dos obst&#225;culos (independetemente do terreno) que seja Nenhum. Se n&#227;o existir, o mapa n&#227;o &#233; v&#225;lido (False == False).
Por outro lado, se existir, a fun&#231;&#227;o ir&#225; verificar o resto da lista no intuito de validar ou n&#227;o o mapa.
<code>mapaValido5 :: Mapa -&gt; Bool 
mapaValido5 (Mapa c []) = True
mapaValido5 (Mapa c ((tr, (x:y)):t))| elem Nenhum (x:y) == False = False
                                    | otherwise = mapaValido5 (Mapa c t)</code></p></div></div><div class="top"><p class="src"><a id="v:mapaValido6" class="def">mapaValido6</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:mapaValido6" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o mapaValido6 compara a largura do mapa com o n&#250;mero de elementos dos obst&#225;culos de cada terreno/linha (comprimento da lista). 
O caso de paragem ir&#225; dar mapa v&#225;lido pois a lista est&#225; vazia.
Quando recebe um Mapa (onde a lista n&#227;o est&#225; vazia), a fun&#231;&#227;o vai comparar a largura atribuida ao Mapa (c) com o comprimento da lista dos obst&#225;culos. Se forem diferentes, o mapa vai dar inv&#225;lido,
uma vez que n&#227;o podem haver obst&#225;culos fora dos limites do mapa e toda a largura do mapa deve estar definida at&#233; os espa&#231;os vazios (Nenhum).
Se no primeiro terreno<em> lista, n&#227;o houver erros</em>problemas/a largura for igual ao n&#250;mero de elementos, ent&#227;o a fun&#231;&#227;o ir&#225; verificar o resto da lista e depois, consoante o resultado (tudo verdadeiro -&gt; mapa v&#225;lido)
vai aferir se o mapa &#233; v&#225;lido ou n&#227;o.
<code>mapaValido6 :: Mapa -&gt; Bool
mapaValido6 (Mapa c []) = True
mapaValido6 (Mapa c ((tr, (x:y)):t)) | c /= length (x:y) = False
                                     | otherwise = mapaValido6 (Mapa c t)</code></p></div></div><div class="top"><p class="src"><a id="v:mapaValido7" class="def">mapaValido7</a> :: <a href="LI12223.html#t:Mapa" title="LI12223">Mapa</a> -&gt; Bool <a href="#v:mapaValido7" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o mapaValido7 verifica se exitem mais de 4 rios seguidos e/ou mais de 5 Estradas ou Relva.
O caso de paragem &#233; o mesmo das outras fun&#231;&#245;es, uma vez que a lista vazia cumpre a condi&#231;&#227;o.
Para os v&#225;rios terrenos utilizamos uma fun&#231;ao auxiliar que agrupa em listas os elementos iguais de terrenos e obst&#225;culos iguais do mapa dado (conta 7).
Na fun&#231;ao mapaValido7 para cada terreno definimos as condi&#231;oes. No geral, comparamos o comprimento da primeira lista criada em conta7 com a condi&#231;ao possivel para cada terreno
(ex: relva e estrada nao podem haver mais que 5 seguidos e no rio mais de 4 seguidos), caso nada contrarie a condi&#231;ao nessa lista entao a fun&#231;ao avalia o resto das listas criadas na conta7.
@ mapaValido7 :: Mapa -&gt; Bool
mapaValido7 (Mapa c []) = True
mapaValido7 (Mapa c ((Estrada n, (x:y)):t)) | (length (head (conta7 ((Estrada n, (x:y)):t)))) &gt; 5 = False
                                            | otherwise = mapaValido7 (Mapa c t)</p><p>mapaValido7 (Mapa c ((Rio n, (x:y)):t)) | (length (head (conta7 ((Rio n, (x:y)):t)))) &gt; 4 = False
                                        | otherwise = mapaValido7 (Mapa c t)</p><p>mapaValido7 (Mapa c ((Relva, (x:y)):t)) | (length (head (conta7 ((Relva, (x:y)):t)))) &gt; 5 = False
                                        | otherwise = mapaValido7 (Mapa c t)</p><p>conta7 :: [(Terreno,[Obstaculo])] -&gt; [[(Terreno, [Obstaculo])]] 
conta7 [] = [] 
conta7 [x] = [[x]]
conta7 ((x,y):(x',y'):t) | x == x' = ((x,y):(head r)) : tail r
                         | otherwise = [(x,y)] :r
                         where r = conta7 ((x',y'):t)
@</p></div></div><div class="top"><p class="src"><a id="v:conta7" class="def">conta7</a> :: [(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])] -&gt; [[(<a href="LI12223.html#t:Terreno" title="LI12223">Terreno</a>, [<a href="LI12223.html#t:Obstaculo" title="LI12223">Obstaculo</a>])]] <a href="#v:conta7" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>